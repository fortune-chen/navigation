// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file RoomPublish.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "RoomPublish.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

Position::Position()
{
    // m_x com.eprosima.idl.parser.typecode.PrimitiveTypeCode@45afc369
    m_x = 0.0;
    // m_y com.eprosima.idl.parser.typecode.PrimitiveTypeCode@799d4f69
    m_y = 0.0;

}

Position::~Position()
{

}

Position::Position(
        const Position& x)
{
    m_x = x.m_x;
    m_y = x.m_y;
}

Position::Position(
        Position&& x)
{
    m_x = x.m_x;
    m_y = x.m_y;
}

Position& Position::operator =(
        const Position& x)
{

    m_x = x.m_x;
    m_y = x.m_y;

    return *this;
}

Position& Position::operator =(
        Position&& x)
{

    m_x = x.m_x;
    m_y = x.m_y;

    return *this;
}

size_t Position::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

size_t Position::getCdrSerializedSize(
        const Position& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void Position::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_x;
    scdr << m_y;

}

void Position::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_x;
    dcdr >> m_y;
}

/*!
 * @brief This function sets a value in member x
 * @param _x New value for member x
 */
void Position::x(
        double _x)
{
    m_x = _x;
}

/*!
 * @brief This function returns the value of member x
 * @return Value of member x
 */
double Position::x() const
{
    return m_x;
}

/*!
 * @brief This function returns a reference to member x
 * @return Reference to member x
 */
double& Position::x()
{
    return m_x;
}

/*!
 * @brief This function sets a value in member y
 * @param _y New value for member y
 */
void Position::y(
        double _y)
{
    m_y = _y;
}

/*!
 * @brief This function returns the value of member y
 * @return Value of member y
 */
double Position::y() const
{
    return m_y;
}

/*!
 * @brief This function returns a reference to member y
 * @return Reference to member y
 */
double& Position::y()
{
    return m_y;
}


size_t Position::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool Position::isKeyDefined()
{
    return false;
}

void Position::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

Contour::Contour()
{
    // m_contour_point com.eprosima.idl.parser.typecode.ArrayTypeCode@1b083826


}

Contour::~Contour()
{
}

Contour::Contour(
        const Contour& x)
{
    m_contour_point = x.m_contour_point;
}

Contour::Contour(
        Contour&& x)
{
    m_contour_point = std::move(x.m_contour_point);
}

Contour& Contour::operator =(
        const Contour& x)
{

    m_contour_point = x.m_contour_point;

    return *this;
}

Contour& Contour::operator =(
        Contour&& x)
{

    m_contour_point = std::move(x.m_contour_point);

    return *this;
}

size_t Contour::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < (32); ++a)
    {
        current_alignment += Position::getMaxCdrSerializedSize(current_alignment);}
    return current_alignment - initial_alignment;
}

size_t Contour::getCdrSerializedSize(
        const Contour& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.contour_point().size(); ++a)
    {
            current_alignment += Position::getCdrSerializedSize(data.contour_point().at(a), current_alignment);
    }
    return current_alignment - initial_alignment;
}

void Contour::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_contour_point;


}

void Contour::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_contour_point;

}

/*!
 * @brief This function copies the value in member contour_point
 * @param _contour_point New value to be copied in member contour_point
 */
void Contour::contour_point(
        const std::array<Position, 32>& _contour_point)
{
    m_contour_point = _contour_point;
}

/*!
 * @brief This function moves the value in member contour_point
 * @param _contour_point New value to be moved in member contour_point
 */
void Contour::contour_point(
        std::array<Position, 32>&& _contour_point)
{
    m_contour_point = std::move(_contour_point);
}

/*!
 * @brief This function returns a constant reference to member contour_point
 * @return Constant reference to member contour_point
 */
const std::array<Position, 32>& Contour::contour_point() const
{
    return m_contour_point;
}

/*!
 * @brief This function returns a reference to member contour_point
 * @return Reference to member contour_point
 */
std::array<Position, 32>& Contour::contour_point()
{
    return m_contour_point;
}

size_t Contour::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool Contour::isKeyDefined()
{
    return false;
}

void Contour::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
     
}

OneRoom::OneRoom()
{
    // m_room_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@214b199c
    m_room_id = 0;
    // m_room_centre com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@20d3d15a

    // m_room_area com.eprosima.idl.parser.typecode.PrimitiveTypeCode@2893de87
    m_room_area = 0.0;
    // m_clean_num com.eprosima.idl.parser.typecode.PrimitiveTypeCode@12d3a4e9
    m_clean_num = 0;
    // m_forbid com.eprosima.idl.parser.typecode.PrimitiveTypeCode@240237d2
    m_forbid = false;
    // m_room_points com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@25a65b77


}

OneRoom::~OneRoom()
{





}

OneRoom::OneRoom(
        const OneRoom& x)
{
    m_room_id = x.m_room_id;
    m_room_centre = x.m_room_centre;
    m_room_area = x.m_room_area;
    m_clean_num = x.m_clean_num;
    m_forbid = x.m_forbid;
    m_room_points = x.m_room_points;
}

OneRoom::OneRoom(
        OneRoom&& x)
{
    m_room_id = x.m_room_id;
    m_room_centre = std::move(x.m_room_centre);
    m_room_area = x.m_room_area;
    m_clean_num = x.m_clean_num;
    m_forbid = x.m_forbid;
    m_room_points = std::move(x.m_room_points);
}

OneRoom& OneRoom::operator =(
        const OneRoom& x)
{

    m_room_id = x.m_room_id;
    m_room_centre = x.m_room_centre;
    m_room_area = x.m_room_area;
    m_clean_num = x.m_clean_num;
    m_forbid = x.m_forbid;
    m_room_points = x.m_room_points;

    return *this;
}

OneRoom& OneRoom::operator =(
        OneRoom&& x)
{

    m_room_id = x.m_room_id;
    m_room_centre = std::move(x.m_room_centre);
    m_room_area = x.m_room_area;
    m_clean_num = x.m_clean_num;
    m_forbid = x.m_forbid;
    m_room_points = std::move(x.m_room_points);

    return *this;
}

size_t OneRoom::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += Position::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += Contour::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t OneRoom::getCdrSerializedSize(
        const OneRoom& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += Position::getCdrSerializedSize(data.room_centre(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += Contour::getCdrSerializedSize(data.room_points(), current_alignment);

    return current_alignment - initial_alignment;
}

void OneRoom::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_room_id;
    scdr << m_room_centre;
    scdr << m_room_area;
    scdr << m_clean_num;
    scdr << m_forbid;
    scdr << m_room_points;

}

void OneRoom::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_room_id;
    dcdr >> m_room_centre;
    dcdr >> m_room_area;
    dcdr >> m_clean_num;
    dcdr >> m_forbid;
    dcdr >> m_room_points;
}

/*!
 * @brief This function sets a value in member room_id
 * @param _room_id New value for member room_id
 */
void OneRoom::room_id(
        int32_t _room_id)
{
    m_room_id = _room_id;
}

/*!
 * @brief This function returns the value of member room_id
 * @return Value of member room_id
 */
int32_t OneRoom::room_id() const
{
    return m_room_id;
}

/*!
 * @brief This function returns a reference to member room_id
 * @return Reference to member room_id
 */
int32_t& OneRoom::room_id()
{
    return m_room_id;
}

/*!
 * @brief This function copies the value in member room_centre
 * @param _room_centre New value to be copied in member room_centre
 */
void OneRoom::room_centre(
        const Position& _room_centre)
{
    m_room_centre = _room_centre;
}

/*!
 * @brief This function moves the value in member room_centre
 * @param _room_centre New value to be moved in member room_centre
 */
void OneRoom::room_centre(
        Position&& _room_centre)
{
    m_room_centre = std::move(_room_centre);
}

/*!
 * @brief This function returns a constant reference to member room_centre
 * @return Constant reference to member room_centre
 */
const Position& OneRoom::room_centre() const
{
    return m_room_centre;
}

/*!
 * @brief This function returns a reference to member room_centre
 * @return Reference to member room_centre
 */
Position& OneRoom::room_centre()
{
    return m_room_centre;
}
/*!
 * @brief This function sets a value in member room_area
 * @param _room_area New value for member room_area
 */
void OneRoom::room_area(
        double _room_area)
{
    m_room_area = _room_area;
}

/*!
 * @brief This function returns the value of member room_area
 * @return Value of member room_area
 */
double OneRoom::room_area() const
{
    return m_room_area;
}

/*!
 * @brief This function returns a reference to member room_area
 * @return Reference to member room_area
 */
double& OneRoom::room_area()
{
    return m_room_area;
}

/*!
 * @brief This function sets a value in member clean_num
 * @param _clean_num New value for member clean_num
 */
void OneRoom::clean_num(
        int32_t _clean_num)
{
    m_clean_num = _clean_num;
}

/*!
 * @brief This function returns the value of member clean_num
 * @return Value of member clean_num
 */
int32_t OneRoom::clean_num() const
{
    return m_clean_num;
}

/*!
 * @brief This function returns a reference to member clean_num
 * @return Reference to member clean_num
 */
int32_t& OneRoom::clean_num()
{
    return m_clean_num;
}

/*!
 * @brief This function sets a value in member forbid
 * @param _forbid New value for member forbid
 */
void OneRoom::forbid(
        bool _forbid)
{
    m_forbid = _forbid;
}

/*!
 * @brief This function returns the value of member forbid
 * @return Value of member forbid
 */
bool OneRoom::forbid() const
{
    return m_forbid;
}

/*!
 * @brief This function returns a reference to member forbid
 * @return Reference to member forbid
 */
bool& OneRoom::forbid()
{
    return m_forbid;
}

/*!
 * @brief This function copies the value in member room_points
 * @param _room_points New value to be copied in member room_points
 */
void OneRoom::room_points(
        const Contour& _room_points)
{
    m_room_points = _room_points;
}

/*!
 * @brief This function moves the value in member room_points
 * @param _room_points New value to be moved in member room_points
 */
void OneRoom::room_points(
        Contour&& _room_points)
{
    m_room_points = std::move(_room_points);
}

/*!
 * @brief This function returns a constant reference to member room_points
 * @return Constant reference to member room_points
 */
const Contour& OneRoom::room_points() const
{
    return m_room_points;
}

/*!
 * @brief This function returns a reference to member room_points
 * @return Reference to member room_points
 */
Contour& OneRoom::room_points()
{
    return m_room_points;
}

size_t OneRoom::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool OneRoom::isKeyDefined()
{
    return false;
}

void OneRoom::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
          
}

RoomPublish::RoomPublish()
{
    // m_room_num com.eprosima.idl.parser.typecode.PrimitiveTypeCode@3bd40a57
    m_room_num = 0;
    // m_room_info com.eprosima.idl.parser.typecode.SequenceTypeCode@fdefd3f


}

RoomPublish::~RoomPublish()
{

}

RoomPublish::RoomPublish(
        const RoomPublish& x)
{
    m_room_num = x.m_room_num;
    m_room_info = x.m_room_info;
}

RoomPublish::RoomPublish(
        RoomPublish&& x)
{
    m_room_num = x.m_room_num;
    m_room_info = std::move(x.m_room_info);
}

RoomPublish& RoomPublish::operator =(
        const RoomPublish& x)
{

    m_room_num = x.m_room_num;
    m_room_info = x.m_room_info;

    return *this;
}

RoomPublish& RoomPublish::operator =(
        RoomPublish&& x)
{

    m_room_num = x.m_room_num;
    m_room_info = std::move(x.m_room_info);

    return *this;
}

size_t RoomPublish::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += OneRoom::getMaxCdrSerializedSize(current_alignment);}


    return current_alignment - initial_alignment;
}

size_t RoomPublish::getCdrSerializedSize(
        const RoomPublish& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.room_info().size(); ++a)
    {
        current_alignment += OneRoom::getCdrSerializedSize(data.room_info().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void RoomPublish::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_room_num;
    scdr << m_room_info;

}

void RoomPublish::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_room_num;
    dcdr >> m_room_info;
}

/*!
 * @brief This function sets a value in member room_num
 * @param _room_num New value for member room_num
 */
void RoomPublish::room_num(
        int32_t _room_num)
{
    m_room_num = _room_num;
}

/*!
 * @brief This function returns the value of member room_num
 * @return Value of member room_num
 */
int32_t RoomPublish::room_num() const
{
    return m_room_num;
}

/*!
 * @brief This function returns a reference to member room_num
 * @return Reference to member room_num
 */
int32_t& RoomPublish::room_num()
{
    return m_room_num;
}

/*!
 * @brief This function copies the value in member room_info
 * @param _room_info New value to be copied in member room_info
 */
void RoomPublish::room_info(
        const std::vector<OneRoom>& _room_info)
{
    m_room_info = _room_info;
}

/*!
 * @brief This function moves the value in member room_info
 * @param _room_info New value to be moved in member room_info
 */
void RoomPublish::room_info(
        std::vector<OneRoom>&& _room_info)
{
    m_room_info = std::move(_room_info);
}

/*!
 * @brief This function returns a constant reference to member room_info
 * @return Constant reference to member room_info
 */
const std::vector<OneRoom>& RoomPublish::room_info() const
{
    return m_room_info;
}

/*!
 * @brief This function returns a reference to member room_info
 * @return Reference to member room_info
 */
std::vector<OneRoom>& RoomPublish::room_info()
{
    return m_room_info;
}

size_t RoomPublish::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool RoomPublish::isKeyDefined()
{
    return false;
}

void RoomPublish::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

Param::Param()
{
    // m_param1 com.eprosima.idl.parser.typecode.PrimitiveTypeCode@7a52f2a2
    m_param1 = 0.0;
    // m_param2 com.eprosima.idl.parser.typecode.PrimitiveTypeCode@78047b92
    m_param2 = 0.0;
    // m_param3 com.eprosima.idl.parser.typecode.PrimitiveTypeCode@8909f18
    m_param3 = 0;
    // m_param4 com.eprosima.idl.parser.typecode.PrimitiveTypeCode@79ca92b9
    m_param4 = 0;
    // m_param5 com.eprosima.idl.parser.typecode.PrimitiveTypeCode@4387b79e
    m_param5 = 0.0;
    // m_param6 com.eprosima.idl.parser.typecode.PrimitiveTypeCode@6e75aa0d
    m_param6 = 0.0;

}

Param::~Param()
{





}

Param::Param(
        const Param& x)
{
    m_param1 = x.m_param1;
    m_param2 = x.m_param2;
    m_param3 = x.m_param3;
    m_param4 = x.m_param4;
    m_param5 = x.m_param5;
    m_param6 = x.m_param6;
}

Param::Param(
        Param&& x)
{
    m_param1 = x.m_param1;
    m_param2 = x.m_param2;
    m_param3 = x.m_param3;
    m_param4 = x.m_param4;
    m_param5 = x.m_param5;
    m_param6 = x.m_param6;
}

Param& Param::operator =(
        const Param& x)
{

    m_param1 = x.m_param1;
    m_param2 = x.m_param2;
    m_param3 = x.m_param3;
    m_param4 = x.m_param4;
    m_param5 = x.m_param5;
    m_param6 = x.m_param6;

    return *this;
}

Param& Param::operator =(
        Param&& x)
{

    m_param1 = x.m_param1;
    m_param2 = x.m_param2;
    m_param3 = x.m_param3;
    m_param4 = x.m_param4;
    m_param5 = x.m_param5;
    m_param6 = x.m_param6;

    return *this;
}

size_t Param::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

size_t Param::getCdrSerializedSize(
        const Param& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void Param::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_param1;
    scdr << m_param2;
    scdr << m_param3;
    scdr << m_param4;
    scdr << m_param5;
    scdr << m_param6;

}

void Param::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_param1;
    dcdr >> m_param2;
    dcdr >> m_param3;
    dcdr >> m_param4;
    dcdr >> m_param5;
    dcdr >> m_param6;
}

/*!
 * @brief This function sets a value in member param1
 * @param _param1 New value for member param1
 */
void Param::param1(
        double _param1)
{
    m_param1 = _param1;
}

/*!
 * @brief This function returns the value of member param1
 * @return Value of member param1
 */
double Param::param1() const
{
    return m_param1;
}

/*!
 * @brief This function returns a reference to member param1
 * @return Reference to member param1
 */
double& Param::param1()
{
    return m_param1;
}

/*!
 * @brief This function sets a value in member param2
 * @param _param2 New value for member param2
 */
void Param::param2(
        double _param2)
{
    m_param2 = _param2;
}

/*!
 * @brief This function returns the value of member param2
 * @return Value of member param2
 */
double Param::param2() const
{
    return m_param2;
}

/*!
 * @brief This function returns a reference to member param2
 * @return Reference to member param2
 */
double& Param::param2()
{
    return m_param2;
}

/*!
 * @brief This function sets a value in member param3
 * @param _param3 New value for member param3
 */
void Param::param3(
        int32_t _param3)
{
    m_param3 = _param3;
}

/*!
 * @brief This function returns the value of member param3
 * @return Value of member param3
 */
int32_t Param::param3() const
{
    return m_param3;
}

/*!
 * @brief This function returns a reference to member param3
 * @return Reference to member param3
 */
int32_t& Param::param3()
{
    return m_param3;
}

/*!
 * @brief This function sets a value in member param4
 * @param _param4 New value for member param4
 */
void Param::param4(
        int32_t _param4)
{
    m_param4 = _param4;
}

/*!
 * @brief This function returns the value of member param4
 * @return Value of member param4
 */
int32_t Param::param4() const
{
    return m_param4;
}

/*!
 * @brief This function returns a reference to member param4
 * @return Reference to member param4
 */
int32_t& Param::param4()
{
    return m_param4;
}

/*!
 * @brief This function sets a value in member param5
 * @param _param5 New value for member param5
 */
void Param::param5(
        double _param5)
{
    m_param5 = _param5;
}

/*!
 * @brief This function returns the value of member param5
 * @return Value of member param5
 */
double Param::param5() const
{
    return m_param5;
}

/*!
 * @brief This function returns a reference to member param5
 * @return Reference to member param5
 */
double& Param::param5()
{
    return m_param5;
}

/*!
 * @brief This function sets a value in member param6
 * @param _param6 New value for member param6
 */
void Param::param6(
        double _param6)
{
    m_param6 = _param6;
}

/*!
 * @brief This function returns the value of member param6
 * @return Value of member param6
 */
double Param::param6() const
{
    return m_param6;
}

/*!
 * @brief This function returns a reference to member param6
 * @return Reference to member param6
 */
double& Param::param6()
{
    return m_param6;
}


size_t Param::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool Param::isKeyDefined()
{
    return false;
}

void Param::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
          
}

SaveMap::SaveMap()
{
    // m_flag com.eprosima.idl.parser.typecode.PrimitiveTypeCode@7ff95560
    m_flag = false;

}

SaveMap::~SaveMap()
{
}

SaveMap::SaveMap(
        const SaveMap& x)
{
    m_flag = x.m_flag;
}

SaveMap::SaveMap(
        SaveMap&& x)
{
    m_flag = x.m_flag;
}

SaveMap& SaveMap::operator =(
        const SaveMap& x)
{

    m_flag = x.m_flag;

    return *this;
}

SaveMap& SaveMap::operator =(
        SaveMap&& x)
{

    m_flag = x.m_flag;

    return *this;
}

size_t SaveMap::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t SaveMap::getCdrSerializedSize(
        const SaveMap& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void SaveMap::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_flag;

}

void SaveMap::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_flag;
}

/*!
 * @brief This function sets a value in member flag
 * @param _flag New value for member flag
 */
void SaveMap::flag(
        bool _flag)
{
    m_flag = _flag;
}

/*!
 * @brief This function returns the value of member flag
 * @return Value of member flag
 */
bool SaveMap::flag() const
{
    return m_flag;
}

/*!
 * @brief This function returns a reference to member flag
 * @return Reference to member flag
 */
bool& SaveMap::flag()
{
    return m_flag;
}


size_t SaveMap::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool SaveMap::isKeyDefined()
{
    return false;
}

void SaveMap::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
     
}

RoomOptimize::RoomOptimize()
{
    // m_flag com.eprosima.idl.parser.typecode.PrimitiveTypeCode@7ea37dbf
    m_flag = false;

}

RoomOptimize::~RoomOptimize()
{
}

RoomOptimize::RoomOptimize(
        const RoomOptimize& x)
{
    m_flag = x.m_flag;
}

RoomOptimize::RoomOptimize(
        RoomOptimize&& x)
{
    m_flag = x.m_flag;
}

RoomOptimize& RoomOptimize::operator =(
        const RoomOptimize& x)
{

    m_flag = x.m_flag;

    return *this;
}

RoomOptimize& RoomOptimize::operator =(
        RoomOptimize&& x)
{

    m_flag = x.m_flag;

    return *this;
}

size_t RoomOptimize::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t RoomOptimize::getCdrSerializedSize(
        const RoomOptimize& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void RoomOptimize::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_flag;

}

void RoomOptimize::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_flag;
}

/*!
 * @brief This function sets a value in member flag
 * @param _flag New value for member flag
 */
void RoomOptimize::flag(
        bool _flag)
{
    m_flag = _flag;
}

/*!
 * @brief This function returns the value of member flag
 * @return Value of member flag
 */
bool RoomOptimize::flag() const
{
    return m_flag;
}

/*!
 * @brief This function returns a reference to member flag
 * @return Reference to member flag
 */
bool& RoomOptimize::flag()
{
    return m_flag;
}


size_t RoomOptimize::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool RoomOptimize::isKeyDefined()
{
    return false;
}

void RoomOptimize::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
     
}

RoomSplit::RoomSplit()
{
    // m_flag com.eprosima.idl.parser.typecode.PrimitiveTypeCode@4b44655e
    m_flag = false;
    // m_split_param com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@290d210d


}

RoomSplit::~RoomSplit()
{

}

RoomSplit::RoomSplit(
        const RoomSplit& x)
{
    m_flag = x.m_flag;
    m_split_param = x.m_split_param;
}

RoomSplit::RoomSplit(
        RoomSplit&& x)
{
    m_flag = x.m_flag;
    m_split_param = std::move(x.m_split_param);
}

RoomSplit& RoomSplit::operator =(
        const RoomSplit& x)
{

    m_flag = x.m_flag;
    m_split_param = x.m_split_param;

    return *this;
}

RoomSplit& RoomSplit::operator =(
        RoomSplit&& x)
{

    m_flag = x.m_flag;
    m_split_param = std::move(x.m_split_param);

    return *this;
}

size_t RoomSplit::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += Param::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t RoomSplit::getCdrSerializedSize(
        const RoomSplit& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += Param::getCdrSerializedSize(data.split_param(), current_alignment);

    return current_alignment - initial_alignment;
}

void RoomSplit::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_flag;
    scdr << m_split_param;

}

void RoomSplit::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_flag;
    dcdr >> m_split_param;
}

/*!
 * @brief This function sets a value in member flag
 * @param _flag New value for member flag
 */
void RoomSplit::flag(
        bool _flag)
{
    m_flag = _flag;
}

/*!
 * @brief This function returns the value of member flag
 * @return Value of member flag
 */
bool RoomSplit::flag() const
{
    return m_flag;
}

/*!
 * @brief This function returns a reference to member flag
 * @return Reference to member flag
 */
bool& RoomSplit::flag()
{
    return m_flag;
}

/*!
 * @brief This function copies the value in member split_param
 * @param _split_param New value to be copied in member split_param
 */
void RoomSplit::split_param(
        const Param& _split_param)
{
    m_split_param = _split_param;
}

/*!
 * @brief This function moves the value in member split_param
 * @param _split_param New value to be moved in member split_param
 */
void RoomSplit::split_param(
        Param&& _split_param)
{
    m_split_param = std::move(_split_param);
}

/*!
 * @brief This function returns a constant reference to member split_param
 * @return Constant reference to member split_param
 */
const Param& RoomSplit::split_param() const
{
    return m_split_param;
}

/*!
 * @brief This function returns a reference to member split_param
 * @return Reference to member split_param
 */
Param& RoomSplit::split_param()
{
    return m_split_param;
}

size_t RoomSplit::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool RoomSplit::isKeyDefined()
{
    return false;
}

void RoomSplit::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

VisualWall::VisualWall()
{
    // m_flag com.eprosima.idl.parser.typecode.PrimitiveTypeCode@1d76aeea
    m_flag = false;
    // m_point com.eprosima.idl.parser.typecode.ArrayTypeCode@78dd667e


}

VisualWall::~VisualWall()
{

}

VisualWall::VisualWall(
        const VisualWall& x)
{
    m_flag = x.m_flag;
    m_point = x.m_point;
}

VisualWall::VisualWall(
        VisualWall&& x)
{
    m_flag = x.m_flag;
    m_point = std::move(x.m_point);
}

VisualWall& VisualWall::operator =(
        const VisualWall& x)
{

    m_flag = x.m_flag;
    m_point = x.m_point;

    return *this;
}

VisualWall& VisualWall::operator =(
        VisualWall&& x)
{

    m_flag = x.m_flag;
    m_point = std::move(x.m_point);

    return *this;
}

size_t VisualWall::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    for(size_t a = 0; a < (2); ++a)
    {
        current_alignment += Position::getMaxCdrSerializedSize(current_alignment);}

    return current_alignment - initial_alignment;
}

size_t VisualWall::getCdrSerializedSize(
        const VisualWall& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    for(size_t a = 0; a < data.point().size(); ++a)
    {
            current_alignment += Position::getCdrSerializedSize(data.point().at(a), current_alignment);
    }

    return current_alignment - initial_alignment;
}

void VisualWall::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_flag;
    scdr << m_point;


}

void VisualWall::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_flag;
    dcdr >> m_point;

}

/*!
 * @brief This function sets a value in member flag
 * @param _flag New value for member flag
 */
void VisualWall::flag(
        bool _flag)
{
    m_flag = _flag;
}

/*!
 * @brief This function returns the value of member flag
 * @return Value of member flag
 */
bool VisualWall::flag() const
{
    return m_flag;
}

/*!
 * @brief This function returns a reference to member flag
 * @return Reference to member flag
 */
bool& VisualWall::flag()
{
    return m_flag;
}

/*!
 * @brief This function copies the value in member point
 * @param _point New value to be copied in member point
 */
void VisualWall::point(
        const std::array<Position, 2>& _point)
{
    m_point = _point;
}

/*!
 * @brief This function moves the value in member point
 * @param _point New value to be moved in member point
 */
void VisualWall::point(
        std::array<Position, 2>&& _point)
{
    m_point = std::move(_point);
}

/*!
 * @brief This function returns a constant reference to member point
 * @return Constant reference to member point
 */
const std::array<Position, 2>& VisualWall::point() const
{
    return m_point;
}

/*!
 * @brief This function returns a reference to member point
 * @return Reference to member point
 */
std::array<Position, 2>& VisualWall::point()
{
    return m_point;
}

size_t VisualWall::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool VisualWall::isKeyDefined()
{
    return false;
}

void VisualWall::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

ForbidArea::ForbidArea()
{
    // m_flag com.eprosima.idl.parser.typecode.PrimitiveTypeCode@402e37bc
    m_flag = false;
    // m_point com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@20d3d15a

    // m_width com.eprosima.idl.parser.typecode.PrimitiveTypeCode@79ad8b2f
    m_width = 0.0;
    // m_height com.eprosima.idl.parser.typecode.PrimitiveTypeCode@1df82230
    m_height = 0.0;

}

ForbidArea::~ForbidArea()
{



}

ForbidArea::ForbidArea(
        const ForbidArea& x)
{
    m_flag = x.m_flag;
    m_point = x.m_point;
    m_width = x.m_width;
    m_height = x.m_height;
}

ForbidArea::ForbidArea(
        ForbidArea&& x)
{
    m_flag = x.m_flag;
    m_point = std::move(x.m_point);
    m_width = x.m_width;
    m_height = x.m_height;
}

ForbidArea& ForbidArea::operator =(
        const ForbidArea& x)
{

    m_flag = x.m_flag;
    m_point = x.m_point;
    m_width = x.m_width;
    m_height = x.m_height;

    return *this;
}

ForbidArea& ForbidArea::operator =(
        ForbidArea&& x)
{

    m_flag = x.m_flag;
    m_point = std::move(x.m_point);
    m_width = x.m_width;
    m_height = x.m_height;

    return *this;
}

size_t ForbidArea::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += Position::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

size_t ForbidArea::getCdrSerializedSize(
        const ForbidArea& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += Position::getCdrSerializedSize(data.point(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void ForbidArea::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_flag;
    scdr << m_point;
    scdr << m_width;
    scdr << m_height;

}

void ForbidArea::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_flag;
    dcdr >> m_point;
    dcdr >> m_width;
    dcdr >> m_height;
}

/*!
 * @brief This function sets a value in member flag
 * @param _flag New value for member flag
 */
void ForbidArea::flag(
        bool _flag)
{
    m_flag = _flag;
}

/*!
 * @brief This function returns the value of member flag
 * @return Value of member flag
 */
bool ForbidArea::flag() const
{
    return m_flag;
}

/*!
 * @brief This function returns a reference to member flag
 * @return Reference to member flag
 */
bool& ForbidArea::flag()
{
    return m_flag;
}

/*!
 * @brief This function copies the value in member point
 * @param _point New value to be copied in member point
 */
void ForbidArea::point(
        const Position& _point)
{
    m_point = _point;
}

/*!
 * @brief This function moves the value in member point
 * @param _point New value to be moved in member point
 */
void ForbidArea::point(
        Position&& _point)
{
    m_point = std::move(_point);
}

/*!
 * @brief This function returns a constant reference to member point
 * @return Constant reference to member point
 */
const Position& ForbidArea::point() const
{
    return m_point;
}

/*!
 * @brief This function returns a reference to member point
 * @return Reference to member point
 */
Position& ForbidArea::point()
{
    return m_point;
}
/*!
 * @brief This function sets a value in member width
 * @param _width New value for member width
 */
void ForbidArea::width(
        double _width)
{
    m_width = _width;
}

/*!
 * @brief This function returns the value of member width
 * @return Value of member width
 */
double ForbidArea::width() const
{
    return m_width;
}

/*!
 * @brief This function returns a reference to member width
 * @return Reference to member width
 */
double& ForbidArea::width()
{
    return m_width;
}

/*!
 * @brief This function sets a value in member height
 * @param _height New value for member height
 */
void ForbidArea::height(
        double _height)
{
    m_height = _height;
}

/*!
 * @brief This function returns the value of member height
 * @return Value of member height
 */
double ForbidArea::height() const
{
    return m_height;
}

/*!
 * @brief This function returns a reference to member height
 * @return Reference to member height
 */
double& ForbidArea::height()
{
    return m_height;
}


size_t ForbidArea::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool ForbidArea::isKeyDefined()
{
    return false;
}

void ForbidArea::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
        
}

RoomMerge::RoomMerge()
{
    // m_flag com.eprosima.idl.parser.typecode.PrimitiveTypeCode@22635ba0
    m_flag = false;
    // m_room_num1 com.eprosima.idl.parser.typecode.PrimitiveTypeCode@13c10b87
    m_room_num1 = 0;
    // m_room_num2 com.eprosima.idl.parser.typecode.PrimitiveTypeCode@6a01e23
    m_room_num2 = 0;

}

RoomMerge::~RoomMerge()
{


}

RoomMerge::RoomMerge(
        const RoomMerge& x)
{
    m_flag = x.m_flag;
    m_room_num1 = x.m_room_num1;
    m_room_num2 = x.m_room_num2;
}

RoomMerge::RoomMerge(
        RoomMerge&& x)
{
    m_flag = x.m_flag;
    m_room_num1 = x.m_room_num1;
    m_room_num2 = x.m_room_num2;
}

RoomMerge& RoomMerge::operator =(
        const RoomMerge& x)
{

    m_flag = x.m_flag;
    m_room_num1 = x.m_room_num1;
    m_room_num2 = x.m_room_num2;

    return *this;
}

RoomMerge& RoomMerge::operator =(
        RoomMerge&& x)
{

    m_flag = x.m_flag;
    m_room_num1 = x.m_room_num1;
    m_room_num2 = x.m_room_num2;

    return *this;
}

size_t RoomMerge::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t RoomMerge::getCdrSerializedSize(
        const RoomMerge& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void RoomMerge::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_flag;
    scdr << m_room_num1;
    scdr << m_room_num2;

}

void RoomMerge::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_flag;
    dcdr >> m_room_num1;
    dcdr >> m_room_num2;
}

/*!
 * @brief This function sets a value in member flag
 * @param _flag New value for member flag
 */
void RoomMerge::flag(
        bool _flag)
{
    m_flag = _flag;
}

/*!
 * @brief This function returns the value of member flag
 * @return Value of member flag
 */
bool RoomMerge::flag() const
{
    return m_flag;
}

/*!
 * @brief This function returns a reference to member flag
 * @return Reference to member flag
 */
bool& RoomMerge::flag()
{
    return m_flag;
}

/*!
 * @brief This function sets a value in member room_num1
 * @param _room_num1 New value for member room_num1
 */
void RoomMerge::room_num1(
        int32_t _room_num1)
{
    m_room_num1 = _room_num1;
}

/*!
 * @brief This function returns the value of member room_num1
 * @return Value of member room_num1
 */
int32_t RoomMerge::room_num1() const
{
    return m_room_num1;
}

/*!
 * @brief This function returns a reference to member room_num1
 * @return Reference to member room_num1
 */
int32_t& RoomMerge::room_num1()
{
    return m_room_num1;
}

/*!
 * @brief This function sets a value in member room_num2
 * @param _room_num2 New value for member room_num2
 */
void RoomMerge::room_num2(
        int32_t _room_num2)
{
    m_room_num2 = _room_num2;
}

/*!
 * @brief This function returns the value of member room_num2
 * @return Value of member room_num2
 */
int32_t RoomMerge::room_num2() const
{
    return m_room_num2;
}

/*!
 * @brief This function returns a reference to member room_num2
 * @return Reference to member room_num2
 */
int32_t& RoomMerge::room_num2()
{
    return m_room_num2;
}


size_t RoomMerge::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool RoomMerge::isKeyDefined()
{
    return false;
}

void RoomMerge::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
       
}

RoomInfo::RoomInfo()
{
    // m_flag com.eprosima.idl.parser.typecode.PrimitiveTypeCode@5a955565
    m_flag = false;

}

RoomInfo::~RoomInfo()
{
}

RoomInfo::RoomInfo(
        const RoomInfo& x)
{
    m_flag = x.m_flag;
}

RoomInfo::RoomInfo(
        RoomInfo&& x)
{
    m_flag = x.m_flag;
}

RoomInfo& RoomInfo::operator =(
        const RoomInfo& x)
{

    m_flag = x.m_flag;

    return *this;
}

RoomInfo& RoomInfo::operator =(
        RoomInfo&& x)
{

    m_flag = x.m_flag;

    return *this;
}

size_t RoomInfo::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t RoomInfo::getCdrSerializedSize(
        const RoomInfo& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void RoomInfo::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_flag;

}

void RoomInfo::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_flag;
}

/*!
 * @brief This function sets a value in member flag
 * @param _flag New value for member flag
 */
void RoomInfo::flag(
        bool _flag)
{
    m_flag = _flag;
}

/*!
 * @brief This function returns the value of member flag
 * @return Value of member flag
 */
bool RoomInfo::flag() const
{
    return m_flag;
}

/*!
 * @brief This function returns a reference to member flag
 * @return Reference to member flag
 */
bool& RoomInfo::flag()
{
    return m_flag;
}


size_t RoomInfo::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool RoomInfo::isKeyDefined()
{
    return false;
}

void RoomInfo::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
     
}

RemoveMap::RemoveMap()
{
    // m_flag com.eprosima.idl.parser.typecode.PrimitiveTypeCode@7fc2413d
    m_flag = false;
    // m_mapid com.eprosima.idl.parser.typecode.PrimitiveTypeCode@f8c1ddd
    m_mapid = 0;

}

RemoveMap::~RemoveMap()
{

}

RemoveMap::RemoveMap(
        const RemoveMap& x)
{
    m_flag = x.m_flag;
    m_mapid = x.m_mapid;
}

RemoveMap::RemoveMap(
        RemoveMap&& x)
{
    m_flag = x.m_flag;
    m_mapid = x.m_mapid;
}

RemoveMap& RemoveMap::operator =(
        const RemoveMap& x)
{

    m_flag = x.m_flag;
    m_mapid = x.m_mapid;

    return *this;
}

RemoveMap& RemoveMap::operator =(
        RemoveMap&& x)
{

    m_flag = x.m_flag;
    m_mapid = x.m_mapid;

    return *this;
}

size_t RemoveMap::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t RemoveMap::getCdrSerializedSize(
        const RemoveMap& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void RemoveMap::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_flag;
    scdr << m_mapid;

}

void RemoveMap::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_flag;
    dcdr >> m_mapid;
}

/*!
 * @brief This function sets a value in member flag
 * @param _flag New value for member flag
 */
void RemoveMap::flag(
        bool _flag)
{
    m_flag = _flag;
}

/*!
 * @brief This function returns the value of member flag
 * @return Value of member flag
 */
bool RemoveMap::flag() const
{
    return m_flag;
}

/*!
 * @brief This function returns a reference to member flag
 * @return Reference to member flag
 */
bool& RemoveMap::flag()
{
    return m_flag;
}

/*!
 * @brief This function sets a value in member mapid
 * @param _mapid New value for member mapid
 */
void RemoveMap::mapid(
        int32_t _mapid)
{
    m_mapid = _mapid;
}

/*!
 * @brief This function returns the value of member mapid
 * @return Value of member mapid
 */
int32_t RemoveMap::mapid() const
{
    return m_mapid;
}

/*!
 * @brief This function returns a reference to member mapid
 * @return Reference to member mapid
 */
int32_t& RemoveMap::mapid()
{
    return m_mapid;
}


size_t RemoveMap::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool RemoveMap::isKeyDefined()
{
    return false;
}

void RemoveMap::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

FunctionOrder::FunctionOrder()
{
    // m_set_savemap com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@23f7d05d

    // m_set_removemap com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@1e730495

    // m_set_optimize com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@7d3a22a9

    // m_set_split com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@1d082e88

    // m_set_wall com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@60704c

    // m_set_area com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@6b19b79

    // m_set_merge com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@2a32de6c

    // m_set_info com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@7692d9cc


}

FunctionOrder::~FunctionOrder()
{







}

FunctionOrder::FunctionOrder(
        const FunctionOrder& x)
{
    m_set_savemap = x.m_set_savemap;
    m_set_removemap = x.m_set_removemap;
    m_set_optimize = x.m_set_optimize;
    m_set_split = x.m_set_split;
    m_set_wall = x.m_set_wall;
    m_set_area = x.m_set_area;
    m_set_merge = x.m_set_merge;
    m_set_info = x.m_set_info;
}

FunctionOrder::FunctionOrder(
        FunctionOrder&& x)
{
    m_set_savemap = std::move(x.m_set_savemap);
    m_set_removemap = std::move(x.m_set_removemap);
    m_set_optimize = std::move(x.m_set_optimize);
    m_set_split = std::move(x.m_set_split);
    m_set_wall = std::move(x.m_set_wall);
    m_set_area = std::move(x.m_set_area);
    m_set_merge = std::move(x.m_set_merge);
    m_set_info = std::move(x.m_set_info);
}

FunctionOrder& FunctionOrder::operator =(
        const FunctionOrder& x)
{

    m_set_savemap = x.m_set_savemap;
    m_set_removemap = x.m_set_removemap;
    m_set_optimize = x.m_set_optimize;
    m_set_split = x.m_set_split;
    m_set_wall = x.m_set_wall;
    m_set_area = x.m_set_area;
    m_set_merge = x.m_set_merge;
    m_set_info = x.m_set_info;

    return *this;
}

FunctionOrder& FunctionOrder::operator =(
        FunctionOrder&& x)
{

    m_set_savemap = std::move(x.m_set_savemap);
    m_set_removemap = std::move(x.m_set_removemap);
    m_set_optimize = std::move(x.m_set_optimize);
    m_set_split = std::move(x.m_set_split);
    m_set_wall = std::move(x.m_set_wall);
    m_set_area = std::move(x.m_set_area);
    m_set_merge = std::move(x.m_set_merge);
    m_set_info = std::move(x.m_set_info);

    return *this;
}

size_t FunctionOrder::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += SaveMap::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RemoveMap::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RoomOptimize::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RoomSplit::getMaxCdrSerializedSize(current_alignment);
    current_alignment += VisualWall::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ForbidArea::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RoomMerge::getMaxCdrSerializedSize(current_alignment);
    current_alignment += RoomInfo::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t FunctionOrder::getCdrSerializedSize(
        const FunctionOrder& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += SaveMap::getCdrSerializedSize(data.set_savemap(), current_alignment);
    current_alignment += RemoveMap::getCdrSerializedSize(data.set_removemap(), current_alignment);
    current_alignment += RoomOptimize::getCdrSerializedSize(data.set_optimize(), current_alignment);
    current_alignment += RoomSplit::getCdrSerializedSize(data.set_split(), current_alignment);
    current_alignment += VisualWall::getCdrSerializedSize(data.set_wall(), current_alignment);
    current_alignment += ForbidArea::getCdrSerializedSize(data.set_area(), current_alignment);
    current_alignment += RoomMerge::getCdrSerializedSize(data.set_merge(), current_alignment);
    current_alignment += RoomInfo::getCdrSerializedSize(data.set_info(), current_alignment);

    return current_alignment - initial_alignment;
}

void FunctionOrder::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_set_savemap;
    scdr << m_set_removemap;
    scdr << m_set_optimize;
    scdr << m_set_split;
    scdr << m_set_wall;
    scdr << m_set_area;
    scdr << m_set_merge;
    scdr << m_set_info;

}

void FunctionOrder::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_set_savemap;
    dcdr >> m_set_removemap;
    dcdr >> m_set_optimize;
    dcdr >> m_set_split;
    dcdr >> m_set_wall;
    dcdr >> m_set_area;
    dcdr >> m_set_merge;
    dcdr >> m_set_info;
}

/*!
 * @brief This function copies the value in member set_savemap
 * @param _set_savemap New value to be copied in member set_savemap
 */
void FunctionOrder::set_savemap(
        const SaveMap& _set_savemap)
{
    m_set_savemap = _set_savemap;
}

/*!
 * @brief This function moves the value in member set_savemap
 * @param _set_savemap New value to be moved in member set_savemap
 */
void FunctionOrder::set_savemap(
        SaveMap&& _set_savemap)
{
    m_set_savemap = std::move(_set_savemap);
}

/*!
 * @brief This function returns a constant reference to member set_savemap
 * @return Constant reference to member set_savemap
 */
const SaveMap& FunctionOrder::set_savemap() const
{
    return m_set_savemap;
}

/*!
 * @brief This function returns a reference to member set_savemap
 * @return Reference to member set_savemap
 */
SaveMap& FunctionOrder::set_savemap()
{
    return m_set_savemap;
}
/*!
 * @brief This function copies the value in member set_removemap
 * @param _set_removemap New value to be copied in member set_removemap
 */
void FunctionOrder::set_removemap(
        const RemoveMap& _set_removemap)
{
    m_set_removemap = _set_removemap;
}

/*!
 * @brief This function moves the value in member set_removemap
 * @param _set_removemap New value to be moved in member set_removemap
 */
void FunctionOrder::set_removemap(
        RemoveMap&& _set_removemap)
{
    m_set_removemap = std::move(_set_removemap);
}

/*!
 * @brief This function returns a constant reference to member set_removemap
 * @return Constant reference to member set_removemap
 */
const RemoveMap& FunctionOrder::set_removemap() const
{
    return m_set_removemap;
}

/*!
 * @brief This function returns a reference to member set_removemap
 * @return Reference to member set_removemap
 */
RemoveMap& FunctionOrder::set_removemap()
{
    return m_set_removemap;
}
/*!
 * @brief This function copies the value in member set_optimize
 * @param _set_optimize New value to be copied in member set_optimize
 */
void FunctionOrder::set_optimize(
        const RoomOptimize& _set_optimize)
{
    m_set_optimize = _set_optimize;
}

/*!
 * @brief This function moves the value in member set_optimize
 * @param _set_optimize New value to be moved in member set_optimize
 */
void FunctionOrder::set_optimize(
        RoomOptimize&& _set_optimize)
{
    m_set_optimize = std::move(_set_optimize);
}

/*!
 * @brief This function returns a constant reference to member set_optimize
 * @return Constant reference to member set_optimize
 */
const RoomOptimize& FunctionOrder::set_optimize() const
{
    return m_set_optimize;
}

/*!
 * @brief This function returns a reference to member set_optimize
 * @return Reference to member set_optimize
 */
RoomOptimize& FunctionOrder::set_optimize()
{
    return m_set_optimize;
}
/*!
 * @brief This function copies the value in member set_split
 * @param _set_split New value to be copied in member set_split
 */
void FunctionOrder::set_split(
        const RoomSplit& _set_split)
{
    m_set_split = _set_split;
}

/*!
 * @brief This function moves the value in member set_split
 * @param _set_split New value to be moved in member set_split
 */
void FunctionOrder::set_split(
        RoomSplit&& _set_split)
{
    m_set_split = std::move(_set_split);
}

/*!
 * @brief This function returns a constant reference to member set_split
 * @return Constant reference to member set_split
 */
const RoomSplit& FunctionOrder::set_split() const
{
    return m_set_split;
}

/*!
 * @brief This function returns a reference to member set_split
 * @return Reference to member set_split
 */
RoomSplit& FunctionOrder::set_split()
{
    return m_set_split;
}
/*!
 * @brief This function copies the value in member set_wall
 * @param _set_wall New value to be copied in member set_wall
 */
void FunctionOrder::set_wall(
        const VisualWall& _set_wall)
{
    m_set_wall = _set_wall;
}

/*!
 * @brief This function moves the value in member set_wall
 * @param _set_wall New value to be moved in member set_wall
 */
void FunctionOrder::set_wall(
        VisualWall&& _set_wall)
{
    m_set_wall = std::move(_set_wall);
}

/*!
 * @brief This function returns a constant reference to member set_wall
 * @return Constant reference to member set_wall
 */
const VisualWall& FunctionOrder::set_wall() const
{
    return m_set_wall;
}

/*!
 * @brief This function returns a reference to member set_wall
 * @return Reference to member set_wall
 */
VisualWall& FunctionOrder::set_wall()
{
    return m_set_wall;
}
/*!
 * @brief This function copies the value in member set_area
 * @param _set_area New value to be copied in member set_area
 */
void FunctionOrder::set_area(
        const ForbidArea& _set_area)
{
    m_set_area = _set_area;
}

/*!
 * @brief This function moves the value in member set_area
 * @param _set_area New value to be moved in member set_area
 */
void FunctionOrder::set_area(
        ForbidArea&& _set_area)
{
    m_set_area = std::move(_set_area);
}

/*!
 * @brief This function returns a constant reference to member set_area
 * @return Constant reference to member set_area
 */
const ForbidArea& FunctionOrder::set_area() const
{
    return m_set_area;
}

/*!
 * @brief This function returns a reference to member set_area
 * @return Reference to member set_area
 */
ForbidArea& FunctionOrder::set_area()
{
    return m_set_area;
}
/*!
 * @brief This function copies the value in member set_merge
 * @param _set_merge New value to be copied in member set_merge
 */
void FunctionOrder::set_merge(
        const RoomMerge& _set_merge)
{
    m_set_merge = _set_merge;
}

/*!
 * @brief This function moves the value in member set_merge
 * @param _set_merge New value to be moved in member set_merge
 */
void FunctionOrder::set_merge(
        RoomMerge&& _set_merge)
{
    m_set_merge = std::move(_set_merge);
}

/*!
 * @brief This function returns a constant reference to member set_merge
 * @return Constant reference to member set_merge
 */
const RoomMerge& FunctionOrder::set_merge() const
{
    return m_set_merge;
}

/*!
 * @brief This function returns a reference to member set_merge
 * @return Reference to member set_merge
 */
RoomMerge& FunctionOrder::set_merge()
{
    return m_set_merge;
}
/*!
 * @brief This function copies the value in member set_info
 * @param _set_info New value to be copied in member set_info
 */
void FunctionOrder::set_info(
        const RoomInfo& _set_info)
{
    m_set_info = _set_info;
}

/*!
 * @brief This function moves the value in member set_info
 * @param _set_info New value to be moved in member set_info
 */
void FunctionOrder::set_info(
        RoomInfo&& _set_info)
{
    m_set_info = std::move(_set_info);
}

/*!
 * @brief This function returns a constant reference to member set_info
 * @return Constant reference to member set_info
 */
const RoomInfo& FunctionOrder::set_info() const
{
    return m_set_info;
}

/*!
 * @brief This function returns a reference to member set_info
 * @return Reference to member set_info
 */
RoomInfo& FunctionOrder::set_info()
{
    return m_set_info;
}

size_t FunctionOrder::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool FunctionOrder::isKeyDefined()
{
    return false;
}

void FunctionOrder::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
            
}

MapColor::MapColor()
{
    // m_color_b com.eprosima.idl.parser.typecode.PrimitiveTypeCode@23529fee
    m_color_b = 0;
    // m_color_g com.eprosima.idl.parser.typecode.PrimitiveTypeCode@4fe767f3
    m_color_g = 0;
    // m_color_r com.eprosima.idl.parser.typecode.PrimitiveTypeCode@2805c96b
    m_color_r = 0;

}

MapColor::~MapColor()
{


}

MapColor::MapColor(
        const MapColor& x)
{
    m_color_b = x.m_color_b;
    m_color_g = x.m_color_g;
    m_color_r = x.m_color_r;
}

MapColor::MapColor(
        MapColor&& x)
{
    m_color_b = x.m_color_b;
    m_color_g = x.m_color_g;
    m_color_r = x.m_color_r;
}

MapColor& MapColor::operator =(
        const MapColor& x)
{

    m_color_b = x.m_color_b;
    m_color_g = x.m_color_g;
    m_color_r = x.m_color_r;

    return *this;
}

MapColor& MapColor::operator =(
        MapColor&& x)
{

    m_color_b = x.m_color_b;
    m_color_g = x.m_color_g;
    m_color_r = x.m_color_r;

    return *this;
}

size_t MapColor::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);



    return current_alignment - initial_alignment;
}

size_t MapColor::getCdrSerializedSize(
        const MapColor& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);



    return current_alignment - initial_alignment;
}

void MapColor::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_color_b;
    scdr << m_color_g;
    scdr << m_color_r;

}

void MapColor::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_color_b;
    dcdr >> m_color_g;
    dcdr >> m_color_r;
}

/*!
 * @brief This function sets a value in member color_b
 * @param _color_b New value for member color_b
 */
void MapColor::color_b(
        int16_t _color_b)
{
    m_color_b = _color_b;
}

/*!
 * @brief This function returns the value of member color_b
 * @return Value of member color_b
 */
int16_t MapColor::color_b() const
{
    return m_color_b;
}

/*!
 * @brief This function returns a reference to member color_b
 * @return Reference to member color_b
 */
int16_t& MapColor::color_b()
{
    return m_color_b;
}

/*!
 * @brief This function sets a value in member color_g
 * @param _color_g New value for member color_g
 */
void MapColor::color_g(
        int16_t _color_g)
{
    m_color_g = _color_g;
}

/*!
 * @brief This function returns the value of member color_g
 * @return Value of member color_g
 */
int16_t MapColor::color_g() const
{
    return m_color_g;
}

/*!
 * @brief This function returns a reference to member color_g
 * @return Reference to member color_g
 */
int16_t& MapColor::color_g()
{
    return m_color_g;
}

/*!
 * @brief This function sets a value in member color_r
 * @param _color_r New value for member color_r
 */
void MapColor::color_r(
        int16_t _color_r)
{
    m_color_r = _color_r;
}

/*!
 * @brief This function returns the value of member color_r
 * @return Value of member color_r
 */
int16_t MapColor::color_r() const
{
    return m_color_r;
}

/*!
 * @brief This function returns a reference to member color_r
 * @return Reference to member color_r
 */
int16_t& MapColor::color_r()
{
    return m_color_r;
}


size_t MapColor::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool MapColor::isKeyDefined()
{
    return false;
}

void MapColor::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
       
}

MapServer::MapServer()
{
    // m_channels com.eprosima.idl.parser.typecode.PrimitiveTypeCode@184cf7cf
    m_channels = 0;
    // m_rows com.eprosima.idl.parser.typecode.PrimitiveTypeCode@2fd6b6c7
    m_rows = 0;
    // m_cols com.eprosima.idl.parser.typecode.PrimitiveTypeCode@5bfa9431
    m_cols = 0;
    // m_point_value com.eprosima.idl.parser.typecode.SequenceTypeCode@5db250b4


}

MapServer::~MapServer()
{



}

MapServer::MapServer(
        const MapServer& x)
{
    m_channels = x.m_channels;
    m_rows = x.m_rows;
    m_cols = x.m_cols;
    m_point_value = x.m_point_value;
}

MapServer::MapServer(
        MapServer&& x)
{
    m_channels = x.m_channels;
    m_rows = x.m_rows;
    m_cols = x.m_cols;
    m_point_value = std::move(x.m_point_value);
}

MapServer& MapServer::operator =(
        const MapServer& x)
{

    m_channels = x.m_channels;
    m_rows = x.m_rows;
    m_cols = x.m_cols;
    m_point_value = x.m_point_value;

    return *this;
}

MapServer& MapServer::operator =(
        MapServer&& x)
{

    m_channels = x.m_channels;
    m_rows = x.m_rows;
    m_cols = x.m_cols;
    m_point_value = std::move(x.m_point_value);

    return *this;
}

size_t MapServer::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += MapColor::getMaxCdrSerializedSize(current_alignment);}


    return current_alignment - initial_alignment;
}

size_t MapServer::getCdrSerializedSize(
        const MapServer& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.point_value().size(); ++a)
    {
        current_alignment += MapColor::getCdrSerializedSize(data.point_value().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void MapServer::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_channels;
    scdr << m_rows;
    scdr << m_cols;
    scdr << m_point_value;

}

void MapServer::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_channels;
    dcdr >> m_rows;
    dcdr >> m_cols;
    dcdr >> m_point_value;
}

/*!
 * @brief This function sets a value in member channels
 * @param _channels New value for member channels
 */
void MapServer::channels(
        int16_t _channels)
{
    m_channels = _channels;
}

/*!
 * @brief This function returns the value of member channels
 * @return Value of member channels
 */
int16_t MapServer::channels() const
{
    return m_channels;
}

/*!
 * @brief This function returns a reference to member channels
 * @return Reference to member channels
 */
int16_t& MapServer::channels()
{
    return m_channels;
}

/*!
 * @brief This function sets a value in member rows
 * @param _rows New value for member rows
 */
void MapServer::rows(
        int16_t _rows)
{
    m_rows = _rows;
}

/*!
 * @brief This function returns the value of member rows
 * @return Value of member rows
 */
int16_t MapServer::rows() const
{
    return m_rows;
}

/*!
 * @brief This function returns a reference to member rows
 * @return Reference to member rows
 */
int16_t& MapServer::rows()
{
    return m_rows;
}

/*!
 * @brief This function sets a value in member cols
 * @param _cols New value for member cols
 */
void MapServer::cols(
        int16_t _cols)
{
    m_cols = _cols;
}

/*!
 * @brief This function returns the value of member cols
 * @return Value of member cols
 */
int16_t MapServer::cols() const
{
    return m_cols;
}

/*!
 * @brief This function returns a reference to member cols
 * @return Reference to member cols
 */
int16_t& MapServer::cols()
{
    return m_cols;
}

/*!
 * @brief This function copies the value in member point_value
 * @param _point_value New value to be copied in member point_value
 */
void MapServer::point_value(
        const std::vector<MapColor>& _point_value)
{
    m_point_value = _point_value;
}

/*!
 * @brief This function moves the value in member point_value
 * @param _point_value New value to be moved in member point_value
 */
void MapServer::point_value(
        std::vector<MapColor>&& _point_value)
{
    m_point_value = std::move(_point_value);
}

/*!
 * @brief This function returns a constant reference to member point_value
 * @return Constant reference to member point_value
 */
const std::vector<MapColor>& MapServer::point_value() const
{
    return m_point_value;
}

/*!
 * @brief This function returns a reference to member point_value
 * @return Reference to member point_value
 */
std::vector<MapColor>& MapServer::point_value()
{
    return m_point_value;
}

size_t MapServer::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool MapServer::isKeyDefined()
{
    return false;
}

void MapServer::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
        
}

MapModify::MapModify()
{
    // m_mapid com.eprosima.idl.parser.typecode.PrimitiveTypeCode@233fe9b6
    m_mapid = 0;

}

MapModify::~MapModify()
{
}

MapModify::MapModify(
        const MapModify& x)
{
    m_mapid = x.m_mapid;
}

MapModify::MapModify(
        MapModify&& x)
{
    m_mapid = x.m_mapid;
}

MapModify& MapModify::operator =(
        const MapModify& x)
{

    m_mapid = x.m_mapid;

    return *this;
}

MapModify& MapModify::operator =(
        MapModify&& x)
{

    m_mapid = x.m_mapid;

    return *this;
}

size_t MapModify::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

size_t MapModify::getCdrSerializedSize(
        const MapModify& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void MapModify::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_mapid;

}

void MapModify::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_mapid;
}

/*!
 * @brief This function sets a value in member mapid
 * @param _mapid New value for member mapid
 */
void MapModify::mapid(
        int32_t _mapid)
{
    m_mapid = _mapid;
}

/*!
 * @brief This function returns the value of member mapid
 * @return Value of member mapid
 */
int32_t MapModify::mapid() const
{
    return m_mapid;
}

/*!
 * @brief This function returns a reference to member mapid
 * @return Reference to member mapid
 */
int32_t& MapModify::mapid()
{
    return m_mapid;
}


size_t MapModify::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool MapModify::isKeyDefined()
{
    return false;
}

void MapModify::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
     
}

Message::Message()
{
    // m_index com.eprosima.idl.parser.typecode.PrimitiveTypeCode@358ee631
    m_index = 0;
    // m_message com.eprosima.idl.parser.typecode.StringTypeCode@ec756bd
    m_message ="";

}

Message::~Message()
{

}

Message::Message(
        const Message& x)
{
    m_index = x.m_index;
    m_message = x.m_message;
}

Message::Message(
        Message&& x)
{
    m_index = x.m_index;
    m_message = std::move(x.m_message);
}

Message& Message::operator =(
        const Message& x)
{

    m_index = x.m_index;
    m_message = x.m_message;

    return *this;
}

Message& Message::operator =(
        Message&& x)
{

    m_index = x.m_index;
    m_message = std::move(x.m_message);

    return *this;
}

size_t Message::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t Message::getCdrSerializedSize(
        const Message& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.message().size() + 1;


    return current_alignment - initial_alignment;
}

void Message::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_index;
    scdr << m_message;

}

void Message::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_index;
    dcdr >> m_message;
}

/*!
 * @brief This function sets a value in member index
 * @param _index New value for member index
 */
void Message::index(
        uint32_t _index)
{
    m_index = _index;
}

/*!
 * @brief This function returns the value of member index
 * @return Value of member index
 */
uint32_t Message::index() const
{
    return m_index;
}

/*!
 * @brief This function returns a reference to member index
 * @return Reference to member index
 */
uint32_t& Message::index()
{
    return m_index;
}

/*!
 * @brief This function copies the value in member message
 * @param _message New value to be copied in member message
 */
void Message::message(
        const std::string& _message)
{
    m_message = _message;
}

/*!
 * @brief This function moves the value in member message
 * @param _message New value to be moved in member message
 */
void Message::message(
        std::string&& _message)
{
    m_message = std::move(_message);
}

/*!
 * @brief This function returns a constant reference to member message
 * @return Constant reference to member message
 */
const std::string& Message::message() const
{
    return m_message;
}

/*!
 * @brief This function returns a reference to member message
 * @return Reference to member message
 */
std::string& Message::message()
{
    return m_message;
}

size_t Message::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool Message::isKeyDefined()
{
    return false;
}

void Message::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}
